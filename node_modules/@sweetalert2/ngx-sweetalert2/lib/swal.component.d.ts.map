{"version":3,"file":"swal.component.d.ts","sources":["swal.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AfterViewInit, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';\nimport Swal, { SweetAlertOptions, SweetAlertResult, SweetAlertUpdatableParameters } from 'sweetalert2';\nimport * as events from './swal-events';\nimport { SweetAlert2LoaderService } from './sweetalert2-loader.service';\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`\n *     and `didDestroy`.\n *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,\n *     there can't be multiple listeners on them, and we need the values they can/must return.\n */\nexport declare class SwalComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {\n    private readonly sweetAlert2Loader;\n    private readonly moduleLevelFireOnInit;\n    private readonly moduleLevelDismissOnDestroy;\n    title: SweetAlertOptions['title'];\n    titleText: SweetAlertOptions['titleText'];\n    text: SweetAlertOptions['text'];\n    html: SweetAlertOptions['html'];\n    footer: SweetAlertOptions['footer'];\n    icon: SweetAlertOptions['icon'];\n    iconColor: SweetAlertOptions['iconColor'];\n    iconHtml: SweetAlertOptions['iconHtml'];\n    backdrop: SweetAlertOptions['backdrop'];\n    toast: SweetAlertOptions['toast'];\n    target: SweetAlertOptions['target'];\n    input: SweetAlertOptions['input'];\n    width: SweetAlertOptions['width'];\n    padding: SweetAlertOptions['padding'];\n    background: SweetAlertOptions['background'];\n    position: SweetAlertOptions['position'];\n    grow: SweetAlertOptions['grow'];\n    showClass: SweetAlertOptions['showClass'];\n    hideClass: SweetAlertOptions['hideClass'];\n    customClass: SweetAlertOptions['customClass'];\n    timer: SweetAlertOptions['timer'];\n    timerProgressBar: SweetAlertOptions['timerProgressBar'];\n    heightAuto: SweetAlertOptions['heightAuto'];\n    allowOutsideClick: SweetAlertOptions['allowOutsideClick'];\n    allowEscapeKey: SweetAlertOptions['allowEscapeKey'];\n    allowEnterKey: SweetAlertOptions['allowEnterKey'];\n    stopKeydownPropagation: SweetAlertOptions['stopKeydownPropagation'];\n    keydownListenerCapture: SweetAlertOptions['keydownListenerCapture'];\n    showConfirmButton: SweetAlertOptions['showConfirmButton'];\n    showDenyButton: SweetAlertOptions['showDenyButton'];\n    showCancelButton: SweetAlertOptions['showCancelButton'];\n    confirmButtonText: SweetAlertOptions['confirmButtonText'];\n    denyButtonText: SweetAlertOptions['denyButtonText'];\n    cancelButtonText: SweetAlertOptions['cancelButtonText'];\n    confirmButtonColor: SweetAlertOptions['confirmButtonColor'];\n    denyButtonColor: SweetAlertOptions['denyButtonColor'];\n    cancelButtonColor: SweetAlertOptions['cancelButtonColor'];\n    confirmButtonAriaLabel: SweetAlertOptions['confirmButtonAriaLabel'];\n    denyButtonAriaLabel: SweetAlertOptions['denyButtonAriaLabel'];\n    cancelButtonAriaLabel: SweetAlertOptions['cancelButtonAriaLabel'];\n    buttonsStyling: SweetAlertOptions['buttonsStyling'];\n    reverseButtons: SweetAlertOptions['reverseButtons'];\n    focusConfirm: SweetAlertOptions['focusConfirm'];\n    focusDeny: SweetAlertOptions['focusDeny'];\n    focusCancel: SweetAlertOptions['focusCancel'];\n    showCloseButton: SweetAlertOptions['showCloseButton'];\n    closeButtonHtml: SweetAlertOptions['closeButtonHtml'];\n    closeButtonAriaLabel: SweetAlertOptions['closeButtonAriaLabel'];\n    loaderHtml: SweetAlertOptions['loaderHtml'];\n    showLoaderOnConfirm: SweetAlertOptions['showLoaderOnConfirm'];\n    preConfirm: SweetAlertOptions['preConfirm'];\n    preDeny: SweetAlertOptions['preDeny'];\n    imageUrl: SweetAlertOptions['imageUrl'];\n    imageWidth: SweetAlertOptions['imageWidth'];\n    imageHeight: SweetAlertOptions['imageHeight'];\n    imageAlt: SweetAlertOptions['imageAlt'];\n    inputLabel: SweetAlertOptions['inputLabel'];\n    inputPlaceholder: SweetAlertOptions['inputPlaceholder'];\n    inputValue: SweetAlertOptions['inputValue'];\n    inputOptions: SweetAlertOptions['inputOptions'];\n    inputAutoTrim: SweetAlertOptions['inputAutoTrim'];\n    inputAttributes: SweetAlertOptions['inputAttributes'];\n    inputValidator: SweetAlertOptions['inputValidator'];\n    returnInputValueOnDeny: SweetAlertOptions['returnInputValueOnDeny'];\n    validationMessage: SweetAlertOptions['validationMessage'];\n    progressSteps: SweetAlertOptions['progressSteps'];\n    currentProgressStep: SweetAlertOptions['currentProgressStep'];\n    progressStepsDistance: SweetAlertOptions['progressStepsDistance'];\n    scrollbarPadding: SweetAlertOptions['scrollbarPadding'];\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n    set swalOptions(options: SweetAlertOptions);\n    /**\n     * Computes the options object that will get passed to SweetAlert2.\n     * Only the properties that have been set at least once on this component will be returned.\n     * Mostly for internal usage.\n     */\n    get swalOptions(): SweetAlertOptions;\n    /**\n     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n     *\n     * Example:\n     *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n     */\n    swalFireOnInit?: boolean;\n    /**\n     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n     */\n    swalDismissOnDestroy?: boolean;\n    set swalVisible(visible: boolean);\n    get swalVisible(): boolean;\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    readonly willOpen: EventEmitter<events.WillOpenEvent>;\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    readonly didOpen: EventEmitter<events.DidOpenEvent>;\n    /**\n     * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n     * repainted on the screen).\n     * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n     * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n     * {@link willOpen}.\n     */\n    readonly didRender: EventEmitter<events.DidRenderEvent>;\n    /**\n     * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n     * being fired).\n     */\n    readonly willClose: EventEmitter<events.WillCloseEvent>;\n    /**\n     * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n     * another popup being fired).\n     */\n    readonly didClose: EventEmitter<void>;\n    /**\n     * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n     * popup.\n     * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n     * {@link didDestroy} over {@link didClose}.\n     */\n    readonly didDestroy: EventEmitter<void>;\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    readonly confirm: EventEmitter<any>;\n    /**\n     * Emits when the user clicks \"Deny\".\n     * This event bears no value.\n     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n     *\n     * Example:\n     *     <swal (deny)=\"handleDeny()\"></swal>\n     *\n     *     public handleDeny(): void {\n     *     }\n     */\n    readonly deny: EventEmitter<void>;\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n     * the modal was programmatically closed (through {@link close} for example).\n     *\n     * Example:\n     *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n     *\n     *     public handleDismiss(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    readonly dismiss: EventEmitter<Swal.DismissReason | undefined>;\n    /**\n     * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n     * what options we have to send to {@link Swal.fire}.\n     */\n    private readonly touchedProps;\n    /**\n     * A function of signature `(propName: string): void` that adds a given property name to the list of\n     * touched properties, ie. {@link touchedProps}.\n     */\n    private readonly markTouched;\n    /**\n     * Is the SweetAlert2 modal represented by this component currently opened?\n     */\n    private isCurrentlyShown;\n    constructor(sweetAlert2Loader: SweetAlert2LoaderService, moduleLevelFireOnInit: boolean, moduleLevelDismissOnDestroy: boolean);\n    /**\n     * Angular lifecycle hook.\n     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n     * causing no delay.\n     */\n    ngOnInit(): void;\n    /**\n     * Angular lifecycle hook.\n     * Fires the modal, if the component or module is configured to do so.\n     */\n    ngAfterViewInit(): void;\n    /**\n     * Angular lifecycle hook.\n     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Angular lifecycle hook.\n     * Closes the SweetAlert when the component is destroyed.\n     */\n    ngOnDestroy(): void;\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n     */\n    fire(): Promise<SweetAlertResult>;\n    /**\n     * Closes the modal, if opened.\n     *\n     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n     *               {@see Swal.close}.\n     */\n    close(result?: SweetAlertResult): Promise<void>;\n    /**\n     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n     * If the modal is not opened, the component options will simply be updated and that's it.\n     *\n     * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n     *\n     * @param options\n     */\n    update(options?: Pick<SweetAlertOptions, SweetAlertUpdatableParameters>): Promise<void>;\n}\n"]}