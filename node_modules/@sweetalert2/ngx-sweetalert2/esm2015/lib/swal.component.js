import { __awaiter } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`
 *     and `didDestroy`.
 *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,
 *     there can't be multiple listeners on them, and we need the values they can/must return.
 */
export class SwalComponent {
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.willOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.didOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is
         * repainted on the screen).
         * Typically, this will happen after `Swal.fire()` or `Swal.update()`.
         * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over
         * {@link willOpen}.
         */
        this.didRender = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup
         * being fired).
         */
        this.willClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to
         * another popup being fired).
         */
        this.didClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another
         * popup.
         * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer
         * {@link didDestroy} over {@link didClose}.
         */
        this.didDestroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * The event value ($event) can be either:
         *  - by default, just `true`,
         *  - when using {@link input}, the input value,
         *  - when using {@link preConfirm}, the return value of this function.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Deny".
         * This event bears no value.
         * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
         * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
         *
         * Example:
         *     <swal (deny)="handleDeny()"></swal>
         *
         *     public handleDeny(): void {
         *     }
         */
        this.deny = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
         * the modal was programmatically closed (through {@link close} for example).
         *
         * Example:
         *     <swal (dismiss)="handleDismiss($event)"></swal>
         *
         *     public handleDismiss(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.dismiss = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        const touchedKeys = Object.keys(options);
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions() {
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        return [...this.touchedProps].reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: this[key] })), {});
    }
    set swalVisible(visible) {
        visible ? this.fire() : this.close();
    }
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit() {
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((key) => !key.startsWith('swal'))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.close();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (dismiss)="myHandler($event)" can be used in templates.
     */
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            const swal = yield this.sweetAlert2Loader.swal;
            const userOptions = this.swalOptions;
            //=> Build the SweetAlert2 options
            const options = Object.assign(Object.assign({}, userOptions), { 
                //=> Handle modal lifecycle events
                willOpen: composeHook(userOptions.willOpen, (modalElement) => {
                    this.willOpen.emit({ modalElement });
                }), didOpen: composeHook(userOptions.didOpen, (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.didOpen.emit({ modalElement });
                }), didRender: composeHook(userOptions.didRender, (modalElement) => {
                    this.didRender.emit({ modalElement });
                }), willClose: composeHook(userOptions.willClose, (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.willClose.emit({ modalElement });
                }), didClose: composeHook(userOptions.didClose, () => {
                    this.didClose.emit();
                }), didDestroy: composeHook(userOptions.didDestroy, () => {
                    this.didDestroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            const result = yield swal.fire(options);
            //=> Emit on (confirm), (deny) or (dismiss)
            switch (true) {
                case result.isConfirmed:
                    this.confirm.emit(result.value);
                    break;
                case result.isDenied:
                    this.deny.emit();
                    break;
                case result.isDismissed:
                    this.dismiss.emit(result.dismiss);
                    break;
            }
            return result;
            function composeHook(userHook, libHook) {
                return (...args) => (libHook(...args), userHook === null || userHook === void 0 ? void 0 : userHook(...args));
            }
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).
     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.
     *               {@see Swal.close}.
     */
    close(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            const allOptions = this.swalOptions;
            const updatableOptions = Object.keys(allOptions)
                .filter(swal.isUpdatableParameter)
                .reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: allOptions[key] })), {});
            swal.update(updatableOptions);
        });
    }
}
SwalComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    icon: [{ type: Input }],
    iconColor: [{ type: Input }],
    iconHtml: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    showClass: [{ type: Input }],
    hideClass: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    timerProgressBar: [{ type: Input }],
    heightAuto: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    stopKeydownPropagation: [{ type: Input }],
    keydownListenerCapture: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showDenyButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    denyButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    denyButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    denyButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusDeny: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonHtml: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    loaderHtml: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    preDeny: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    inputLabel: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    returnInputValueOnDeny: [{ type: Input }],
    validationMessage: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    scrollbarPadding: [{ type: Input }],
    swalOptions: [{ type: Input }],
    swalFireOnInit: [{ type: Input }],
    swalDismissOnDestroy: [{ type: Input }],
    swalVisible: [{ type: Input }],
    willOpen: [{ type: Output }],
    didOpen: [{ type: Output }],
    didRender: [{ type: Output }],
    willClose: [{ type: Output }],
    didClose: [{ type: Output }],
    didDestroy: [{ type: Output }],
    confirm: [{ type: Output }],
    deny: [{ type: Output }],
    dismiss: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc3dlZXRhbGVydDIvc3JjL2xpYi9zd2FsLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNZLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFDOUUsTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFOUQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFeEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFPSCxNQUFNLE9BQU8sYUFBYTtJQWtQdEIsWUFDcUIsaUJBQTJDLEVBQ2xCLHFCQUE4QixFQUN4QiwyQkFBb0M7UUFGbkUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUEwQjtRQUNsQiwwQkFBcUIsR0FBckIscUJBQXFCLENBQVM7UUFDeEIsZ0NBQTJCLEdBQTNCLDJCQUEyQixDQUFTO1FBakh4Rjs7V0FFRztRQUVhLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBd0IsQ0FBQztRQUVwRTs7V0FFRztRQUVhLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBdUIsQ0FBQztRQUVsRTs7Ozs7O1dBTUc7UUFFYSxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQXlCLENBQUM7UUFFdEU7OztXQUdHO1FBRWEsY0FBUyxHQUFHLElBQUksWUFBWSxFQUF5QixDQUFDO1FBRXRFOzs7V0FHRztRQUVhLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRXBEOzs7OztXQUtHO1FBRWEsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFFdEQ7Ozs7Ozs7Ozs7Ozs7V0FhRztRQUVhLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBRWxEOzs7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Szt1QkFDTCxLQUFLO21CQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLOzBCQUNMLEtBQUs7b0JBQ0wsS0FBSzsrQkFDTCxLQUFLO3lCQUNMLEtBQUs7Z0NBQ0wsS0FBSzs2QkFDTCxLQUFLOzRCQUNMLEtBQUs7cUNBQ0wsS0FBSztxQ0FDTCxLQUFLO2dDQUNMLEtBQUs7NkJBQ0wsS0FBSzsrQkFDTCxLQUFLO2dDQUNMLEtBQUs7NkJBQ0wsS0FBSzsrQkFDTCxLQUFLO2lDQUNMLEtBQUs7OEJBQ0wsS0FBSztnQ0FDTCxLQUFLO3FDQUNMLEtBQUs7a0NBQ0wsS0FBSztvQ0FDTCxLQUFLOzZCQUNMLEtBQUs7NkJBQ0wsS0FBSzsyQkFDTCxLQUFLO3dCQUNMLEtBQUs7MEJBQ0wsS0FBSzs4QkFDTCxLQUFLOzhCQUNMLEtBQUs7bUNBQ0wsS0FBSzt5QkFDTCxLQUFLO2tDQUNMLEtBQUs7eUJBQ0wsS0FBSztzQkFDTCxLQUFLO3VCQUNMLEtBQUs7eUJBQ0wsS0FBSzswQkFDTCxLQUFLO3VCQUNMLEtBQUs7eUJBQ0wsS0FBSzsrQkFDTCxLQUFLO3lCQUNMLEtBQUs7MkJBQ0wsS0FBSzs0QkFDTCxLQUFLOzhCQUNMLEtBQUs7NkJBQ0wsS0FBSztxQ0FDTCxLQUFLO2dDQUNMLEtBQUs7NEJBQ0wsS0FBSztrQ0FDTCxLQUFLO29DQUNMLEtBQUs7K0JBQ0wsS0FBSzswQkFhTCxLQUFLOzZCQStCTCxLQUFLO21DQU9MLEtBQUs7MEJBR0wsS0FBSzt1QkFZTCxNQUFNO3NCQU1OLE1BQU07d0JBVU4sTUFBTTt3QkFPTixNQUFNO3VCQU9OLE1BQU07eUJBU04sTUFBTTtzQkFpQk4sTUFBTTttQkFlTixNQUFNO3NCQWdCTixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsXG4gICAgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRSZXN1bHQsIFN3ZWV0QWxlcnRVcGRhdGFibGVQYXJhbWV0ZXJzIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgZGlzbWlzc09uRGVzdHJveVRva2VuLCBmaXJlT25Jbml0VG9rZW4gfSBmcm9tICcuL2RpJztcbmltcG9ydCAqIGFzIGV2ZW50cyBmcm9tICcuL3N3YWwtZXZlbnRzJztcbmltcG9ydCB7IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSB9IGZyb20gJy4vc3dlZXRhbGVydDItbG9hZGVyLnNlcnZpY2UnO1xuXG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZSBldmVuIGlmIGJvdGggbGlicmFyaWVzIGRvIG5vdCBldm9sdmUgaW4gc3luYy5cbiAqXG4gKiAoPykgSWYgeW91IHdhbnQgdG8gdXNlIGFuIG9iamVjdCB0aGF0IGRlY2xhcmVzIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zIGFsbCBhdCBvbmNlIHJhdGhlciB0aGFuIG1hbnkgQElucHV0cyxcbiAqICAgICB0YWtlIGEgbG9vayBhdCBbc3dhbE9wdGlvbnNdLCB0aGF0IGxldHMgeW91IHBhc3MgYSBmdWxsIHtAbGluayBTd2VldEFsZXJ0T3B0aW9uc30gb2JqZWN0LlxuICpcbiAqICg/KSBJZiB5b3UgYXJlIHJlYWRpbmcgdGhlIFR5cGVTY3JpcHQgc291cmNlIG9mIHRoaXMgY29tcG9uZW50LCB5b3UgbWF5IHRoaW5rIHRoYXQgaXQncyBhIGxvdCBvZiBjb2RlLlxuICogICAgIEJlIHN1cmUgdGhhdCBhIGxvdCBvZiB0aGlzIGNvZGUgaXMgdHlwZXMgYW5kIEFuZ3VsYXIgYm9pbGVycGxhdGUuIENvbXBpbGVkIGFuZCBtaW5pZmllZCBjb2RlIGlzIG11Y2ggc21hbGxlci5cbiAqICAgICBJZiB5b3UgYXJlIHJlYWxseSBjb25jZXJuZWQgYWJvdXQgcGVyZm9ybWFuY2UgYW5kL29yIGRvbid0IGNhcmUgYWJvdXQgdGhlIEFQSSBhbmQgaXRzIGNvbnZlbmllbnQgaW50ZWdyYXRpb25cbiAqICAgICB3aXRoIEFuZ3VsYXIgKG5vdGFibHkgY2hhbmdlIGRldGVjdGlvbiBhbmQgdHJhbnNjbHVzaW9uKSwgeW91IG1heSB0b3RhbGx5IHVzZSBTd2VldEFsZXJ0MiBuYXRpdmVseSBhcyB3ZWxsIDspXG4gKlxuICogLyFcXCBTb21lIFN3ZWV0QWxlcnQgb3B0aW9ucyBhcmVuJ3QgQElucHV0cyBidXQgQE91dHB1dHM6IGB3aWxsT3BlbmAsIGBkaWRPcGVuYCwgYGRpZFJlbmRlcmAsIGB3aWxsQ2xvc2VgLCBgZGlkQ2xvc2VgXG4gKiAgICAgYW5kIGBkaWREZXN0cm95YC5cbiAqICAgICBIb3dldmVyLCBgcHJlQ29uZmlybWAsIGBwcmVEZW55YCBhbmQgYGlucHV0VmFsaWRhdG9yYCBhcmUgc3RpbGwgQElucHV0cyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBldmVudCBoYW5kbGVycyxcbiAqICAgICB0aGVyZSBjYW4ndCBiZSBtdWx0aXBsZSBsaXN0ZW5lcnMgb24gdGhlbSwgYW5kIHdlIG5lZWQgdGhlIHZhbHVlcyB0aGV5IGNhbi9tdXN0IHJldHVybi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICAgIHNlbGVjdG9yOiAnc3dhbCcsXG4gICAgdGVtcGxhdGU6ICcnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb246IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGhpZGVDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2hpZGVDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXN0b21DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2N1c3RvbUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyOiBTd2VldEFsZXJ0T3B0aW9uc1sndGltZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXJQcm9ncmVzc0JhcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyUHJvZ3Jlc3NCYXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaGVpZ2h0QXV0bzogU3dlZXRBbGVydE9wdGlvbnNbJ2hlaWdodEF1dG8nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dPdXRzaWRlQ2xpY2s6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd091dHNpZGVDbGljayddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VzY2FwZUtleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RXNjYXBlS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RW50ZXJLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VudGVyS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIHN0b3BLZXlkb3duUHJvcGFnYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydzdG9wS2V5ZG93blByb3BhZ2F0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IFN3ZWV0QWxlcnRPcHRpb25zWydrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDb25maXJtQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NvbmZpcm1CdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0RlbnlCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93RGVueUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2FuY2VsQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NhbmNlbEJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGRlbnlCdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snZGVueUJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGRlbnlCdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2RlbnlCdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGRlbnlCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydkZW55QnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBidXR0b25zU3R5bGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ2J1dHRvbnNTdHlsaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIHJldmVyc2VCdXR0b25zOiBTd2VldEFsZXJ0T3B0aW9uc1sncmV2ZXJzZUJ1dHRvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzRGVueTogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzRGVueSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NhbmNlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ2FuY2VsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbG9zZUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbG9zZUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBsb2FkZXJIdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snbG9hZGVySHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93TG9hZGVyT25Db25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0xvYWRlck9uQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcmVDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJlQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcmVEZW55OiBTd2VldEFsZXJ0T3B0aW9uc1sncHJlRGVueSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVVybDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlVXJsJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlV2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVdpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlSGVpZ2h0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VIZWlnaHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VBbHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUFsdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dExhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFBsYWNlaG9sZGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRQbGFjZWhvbGRlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbHVlOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWx1ZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dE9wdGlvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdXRvVHJpbTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXV0b1RyaW0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdHRyaWJ1dGVzOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdHRyaWJ1dGVzJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsaWRhdG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWxpZGF0b3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcmV0dXJuSW5wdXRWYWx1ZU9uRGVueTogU3dlZXRBbGVydE9wdGlvbnNbJ3JldHVybklucHV0VmFsdWVPbkRlbnknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdmFsaWRhdGlvbk1lc3NhZ2U6IFN3ZWV0QWxlcnRPcHRpb25zWyd2YWxpZGF0aW9uTWVzc2FnZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXJyZW50UHJvZ3Jlc3NTdGVwOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VycmVudFByb2dyZXNzU3RlcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzRGlzdGFuY2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2Nyb2xsYmFyUGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3Njcm9sbGJhclBhZGRpbmcnXTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBTd2VldEFsZXJ0MiBuYXRpdmUgb3B0aW9ucywgdXNlZnVsIGlmOlxuICAgICAqICAtIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgQElucHV0cyBmb3IgcHJhY3RpY2FsL3BoaWxvc29waGljYWwgcmVhc29ucyA7XG4gICAgICogIC0gdGhlcmUgYXJlIG1pc3NpbmcgQElucHV0cyBiZWNhdXNlIG5neC1zd2VldGFsZXJ0MiBpc24ndCB1cC10by1kYXRlIHdpdGggU3dlZXRBbGVydDIncyBsYXRlc3QgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcHJvcGVydHkgZG9lcyBOT1QgZXJhc2Ugd2hhdCBoYXMgYmVlbiBzZXQgYmVmb3JlIHVubGVzcyB5b3Ugc3BlY2lmeSB0aGVcbiAgICAgKiAgICAgcHJldmlvdXMgcHJvcGVydGllcyB5b3Ugd2FudCB0byBlcmFzZSBhZ2Fpbi5cbiAgICAgKiAgICAgSWUuIHNldHRpbmcgeyB0aXRsZTogJ1RpdGxlJyB9IGFuZCB0aGVuIHsgdGV4dDogJ1RleHQnIH0gd2lsbCBnaXZlIHsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9LlxuICAgICAqXG4gICAgICogLyFcXCBCZSBhd2FyZSB0aGF0IHRoZSBvcHRpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3Qgd2lsbCBvdmVycmlkZSB0aGUgQElucHV0cyBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsT3B0aW9ucyhvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucykge1xuICAgICAgICAvLz0+IFVwZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBNYXJrIGNoYW5nZWQgcHJvcGVydGllcyBhcyB0b3VjaGVkXG4gICAgICAgIGNvbnN0IHRvdWNoZWRLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykgYXMgQXJyYXk8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+O1xuICAgICAgICB0b3VjaGVkS2V5cy5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvcHRpb25zIG9iamVjdCB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBTd2VldEFsZXJ0Mi5cbiAgICAgKiBPbmx5IHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHNldCBhdCBsZWFzdCBvbmNlIG9uIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogTW9zdGx5IGZvciBpbnRlcm5hbCB1c2FnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN3YWxPcHRpb25zKCk6IFN3ZWV0QWxlcnRPcHRpb25zIHtcbiAgICAgICAgLy89PiBXZSB3aWxsIGNvbXB1dGUgdGhlIG9wdGlvbnMgb2JqZWN0IGJhc2VkIG9uIHRoZSBvcHRpb24ga2V5cyB0aGF0IGFyZSBrbm93biB0byBoYXZlIGNoYW5nZWQuXG4gICAgICAgIC8vICAgVGhhdCBhdm9pZHMgcGFzc2luZyBhIGdpZ2FudGljIG9iamVjdCB0byBTd2VldEFsZXJ0MiwgbWFraW5nIGRlYnVnZ2luZyBlYXNpZXIgYW5kIHBvdGVudGlhbGx5XG4gICAgICAgIC8vICAgYXZvaWRpbmcgc2lkZSBlZmZlY3RzLlxuICAgICAgICByZXR1cm4gWy4uLnRoaXMudG91Y2hlZFByb3BzXS5yZWR1Y2U8U3dlZXRBbGVydE9wdGlvbnM+KFxuICAgICAgICAgICAgKG9iaiwga2V5KSA9PiAoeyAuLi5vYmosIFtrZXldOiB0aGlzW2tleSBhcyBrZXlvZiB0aGlzXSB9KSxcbiAgICAgICAgICAgIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGZpcmUgdGhlIG1vZGFsIGFzIHNvb24gYXMgdGhlIDxzd2FsPiBjb21wb25lbnQgaXMgY3JlYXRlZCBhbmQgaW5pdGlhbGl6ZWQgaW4gdGhlIHZpZXcuXG4gICAgICogV2hlbiBsZWZ0IHVuZGVmaW5lZCAoZGVmYXVsdCksIHRoZSB2YWx1ZSB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBtb2R1bGUgY29uZmlndXJhdGlvbiwgd2hpY2ggaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsICpuZ0lmPVwiZXJyb3JcIiBbdGl0bGVdPVwiZXJyb3IudGl0bGVcIiBbdGV4dF09XCJlcnJvci50ZXh0XCIgaWNvbj1cImVycm9yXCIgW3N3YWxGaXJlT25Jbml0XT1cInRydWVcIj48L3N3YWw+XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbEZpcmVPbkluaXQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkaXNtaXNzIHRoZSBtb2RhbCB3aGVuIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGRlc3Ryb3llZCBieSBBbmd1bGFyIChmb3IgYW55IHJlYXNvbikgb3Igbm90LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2FsRGlzbWlzc09uRGVzdHJveT86IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbFZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB2aXNpYmxlID8gdGhpcy5maXJlKCkgOiB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzd2FsVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDdXJyZW50bHlTaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gU3luY2hyb25vdXNseSBydW5zIGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24gb24gc2NyZWVuLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSB3aWxsT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLldpbGxPcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gU3luY2hyb25vdXNseSBydW5zIGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24gb24gc2NyZWVuLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkaWRPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuRGlkT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIFN5bmNocm9ub3VzbHkgcnVucyBhZnRlciB0aGUgcG9wdXAgRE9NIGhhcyBiZWVuIHVwZGF0ZWQgKGllLiBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXNcbiAgICAgKiByZXBhaW50ZWQgb24gdGhlIHNjcmVlbikuXG4gICAgICogVHlwaWNhbGx5LCB0aGlzIHdpbGwgaGFwcGVuIGFmdGVyIGBTd2FsLmZpcmUoKWAgb3IgYFN3YWwudXBkYXRlKClgLlxuICAgICAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gY2hhbmdlcyBpbiB0aGUgcG9wdXAncyBET00sIHRoYXQgc3Vydml2ZSBgU3dhbC51cGRhdGUoKWAsIHByZWZlciB7QGxpbmsgZGlkUmVuZGVyfSBvdmVyXG4gICAgICoge0BsaW5rIHdpbGxPcGVufS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGlkUmVuZGVyID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuRGlkUmVuZGVyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gU3luY2hyb25vdXNseSBydW5zIHdoZW4gdGhlIHBvcHVwIGNsb3NlcyBieSB1c2VyIGludGVyYWN0aW9uIChhbmQgbm90IGR1ZSB0byBhbm90aGVyIHBvcHVwXG4gICAgICogYmVpbmcgZmlyZWQpLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSB3aWxsQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5XaWxsQ2xvc2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBBc3luY2hyb25vdXNseSBydW5zIGFmdGVyIHRoZSBwb3B1cCBoYXMgYmVlbiBkaXNwb3NlZCBieSB1c2VyIGludGVyYWN0aW9uIChhbmQgbm90IGR1ZSB0b1xuICAgICAqIGFub3RoZXIgcG9wdXAgYmVpbmcgZmlyZWQpLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkaWRDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBTeW5jaHJvbm91c2x5IHJ1bnMgYWZ0ZXIgcG9wdXAgaGFzIGJlZW4gZGVzdHJveWVkIGVpdGhlciBieSB1c2VyIGludGVyYWN0aW9uIG9yIGJ5IGFub3RoZXJcbiAgICAgKiBwb3B1cC5cbiAgICAgKiBJZiB5b3UgaGF2ZSBjbGVhbnVwIG9wZXJhdGlvbnMgdGhhdCB5b3UgbmVlZCB0byByZWxpYWJseSBleGVjdXRlIGVhY2ggdGltZSBhIG1vZGFsIGlzIGNsb3NlZCwgcHJlZmVyXG4gICAgICoge0BsaW5rIGRpZERlc3Ryb3l9IG92ZXIge0BsaW5rIGRpZENsb3NlfS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGlkRGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ29uZmlybVwiLlxuICAgICAqIFRoZSBldmVudCB2YWx1ZSAoJGV2ZW50KSBjYW4gYmUgZWl0aGVyOlxuICAgICAqICAtIGJ5IGRlZmF1bHQsIGp1c3QgYHRydWVgLFxuICAgICAqICAtIHdoZW4gdXNpbmcge0BsaW5rIGlucHV0fSwgdGhlIGlucHV0IHZhbHVlLFxuICAgICAqICAtIHdoZW4gdXNpbmcge0BsaW5rIHByZUNvbmZpcm19LCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY29uZmlybSk9XCJoYW5kbGVDb25maXJtKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbmZpcm0gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiRGVueVwiLlxuICAgICAqIFRoaXMgZXZlbnQgYmVhcnMgbm8gdmFsdWUuXG4gICAgICogVXNlIGAoZGVueSlgIChhbG9uZyB3aXRoIHtAbGluayBzaG93RGVueUJ1dHRvbn0pIHdoZW4geW91IHdhbnQgYSBtb2RhbCB3aXRoIHRocmVlIGJ1dHRvbnMgKGNvbmZpcm0sIGRlbnkgYW5kXG4gICAgICogY2FuY2VsKSwgYW5kL29yIHdoZW4geW91IHdhbnQgdG8gaGFuZGxlIGNsZWFyIHJlZnVzYWwgaW4gYSBzZXBhcmF0ZSB3YXkgdGhhbiBzaW1wbGUgZGlzbWlzc2FsLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGRlbnkpPVwiaGFuZGxlRGVueSgpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVEZW55KCk6IHZvaWQge1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRlbnkgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBUaGUgZXZlbnQgdmFsdWUgKCRldmVudCkgaXMgYSBzdHJpbmcgdGhhdCBleHBsYWlucyBob3cgdGhlIG1vZGFsIHdhcyBkaXNtaXNzZWQuIEl0IGlzIGB1bmRlZmluZWRgIHdoZW5cbiAgICAgKiB0aGUgbW9kYWwgd2FzIHByb2dyYW1tYXRpY2FsbHkgY2xvc2VkICh0aHJvdWdoIHtAbGluayBjbG9zZX0gZm9yIGV4YW1wbGUpLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGRpc21pc3MpPVwiaGFuZGxlRGlzbWlzcygkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVEaXNtaXNzKHJlYXNvbjogRGlzbWlzc1JlYXNvbiB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCAndGltZXInIG9yIHVuZGVmaW5lZC5cbiAgICAgKiAgICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmdcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkaXNtaXNzID0gbmV3IEV2ZW50RW1pdHRlcjxTd2FsLkRpc21pc3NSZWFzb24gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIFNldCByZXRhaW5zIHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSBASW5wdXRzLCBzbyB3ZSBjYW4ga25vdyBwcmVjaXNlbHlcbiAgICAgKiB3aGF0IG9wdGlvbnMgd2UgaGF2ZSB0byBzZW5kIHRvIHtAbGluayBTd2FsLmZpcmV9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdG91Y2hlZFByb3BzID0gbmV3IFNldDxrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucz4oKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gb2Ygc2lnbmF0dXJlIGAocHJvcE5hbWU6IHN0cmluZyk6IHZvaWRgIHRoYXQgYWRkcyBhIGdpdmVuIHByb3BlcnR5IG5hbWUgdG8gdGhlIGxpc3Qgb2ZcbiAgICAgKiB0b3VjaGVkIHByb3BlcnRpZXMsIGllLiB7QGxpbmsgdG91Y2hlZFByb3BzfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtUb3VjaGVkID0gdGhpcy50b3VjaGVkUHJvcHMuYWRkLmJpbmQodGhpcy50b3VjaGVkUHJvcHMpO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIFN3ZWV0QWxlcnQyIG1vZGFsIHJlcHJlc2VudGVkIGJ5IHRoaXMgY29tcG9uZW50IGN1cnJlbnRseSBvcGVuZWQ/XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI6IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSxcbiAgICAgICAgQEluamVjdChmaXJlT25Jbml0VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxGaXJlT25Jbml0OiBib29sZWFuLFxuICAgICAgICBASW5qZWN0KGRpc21pc3NPbkRlc3Ryb3lUb2tlbikgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3k6IGJvb2xlYW4pIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEFza3MgdGhlIFN3ZWV0QWxlcnQyIGxvYWRlciBzZXJ2aWNlIHRvIHByZWxvYWQgdGhlIFN3ZWV0QWxlcnQyIGxpYnJhcnksIHNvIGl0IGJlZ2lucyB0byBiZSBsb2FkZWQgb25seSBpZiB0aGVyZVxuICAgICAqIGlzIGEgPHN3YWw+IGNvbXBvbmVudCBzb21ld2hlcmUsIGFuZCBpcyBwcm9iYWJseSBmdWxseSBsb2FkZWQgd2hlbiB0aGUgbW9kYWwgaGFzIHRvIGJlIGRpc3BsYXllZCxcbiAgICAgKiBjYXVzaW5nIG5vIGRlbGF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy89PiBQcmVsb2FkIFN3ZWV0QWxlcnQyIGxpYnJhcnkgaW4gY2FzZSB0aGlzIGNvbXBvbmVudCBpcyBhY3RpdmF0ZWQuXG4gICAgICAgIHRoaXMuc3dlZXRBbGVydDJMb2FkZXIucHJlbG9hZFN3ZWV0QWxlcnRMaWJyYXJ5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBGaXJlcyB0aGUgbW9kYWwsIGlmIHRoZSBjb21wb25lbnQgb3IgbW9kdWxlIGlzIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmlyZU9uSW5pdCA9IHRoaXMuc3dhbEZpcmVPbkluaXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRmlyZU9uSW5pdFxuICAgICAgICAgICAgOiB0aGlzLnN3YWxGaXJlT25Jbml0O1xuXG4gICAgICAgIGZpcmVPbkluaXQgJiYgdGhpcy5maXJlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBVcGRhdGVzIHRoZSBTd2VldEFsZXJ0IG9wdGlvbnMsIGFuZCBpZiB0aGUgbW9kYWwgaXMgb3BlbmVkLCBhc2tzIFN3ZWV0QWxlcnQgdG8gcmVuZGVyIGl0IGFnYWluLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIC8vPT4gRm9yIGVhY2ggY2hhbmdlZCBASW5wdXQgdGhhdCBtYXRjaGVzIGEgU3dlZXRBbGVydDIgb3B0aW9uLCBtYXJrIGFzIHRvdWNoZWQgc28gd2UgY2FuXG4gICAgICAgIC8vICAgc2VuZCBpdCB3aXRoIHRoZSBuZXh0IGZpcmUoKSBvciB1cGRhdGUoKSBjYWxscy5cbiAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcylcbiAgICAgICAgICAgIC8vPT4gSWYgdGhlIGZpbHRlcmluZyBsb2dpYyBiZWNvbWVzIG1vcmUgY29tcGxleCBoZXJlLCB3ZSBjYW4gdXNlIFN3YWwuaXNWYWxpZFBhcmFtZXRlclxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KToga2V5IGlzIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zID0+ICFrZXkuc3RhcnRzV2l0aCgnc3dhbCcpKVxuICAgICAgICAgICAgLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG5cbiAgICAgICAgLy89PiBFdmVudHVhbGx5IHRyaWdnZXIgcmUtcmVuZGVyIGlmIHRoZSBtb2RhbCBpcyBvcGVuLlxuICAgICAgICB2b2lkIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBDbG9zZXMgdGhlIFN3ZWV0QWxlcnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUmVsZWFzZSB0aGUgbW9kYWwgaWYgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYW5kIGlmIHRoYXQgYmVoYXZpb3VyIGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgICAgY29uc3QgZGlzbWlzc09uRGVzdHJveSA9IHRoaXMuc3dhbERpc21pc3NPbkRlc3Ryb3kgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRGlzbWlzc09uRGVzdHJveVxuICAgICAgICAgICAgOiB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95O1xuXG4gICAgICAgIGRpc21pc3NPbkRlc3Ryb3kgJiYgdGhpcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBTd2VldEFsZXJ0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgU3dlZXRBbGVydDIgcHJvbWlzZSBmb3IgY29udmVuaWVuY2UgYW5kIHVzZSBpbiBjb2RlIGJlaGluZCB0ZW1wbGF0ZXMuXG4gICAgICogT3RoZXJ3aXNlLCAoY29uZmlybSk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGFuZCAoZGlzbWlzcyk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGNhbiBiZSB1c2VkIGluIHRlbXBsYXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZmlyZSgpOiBQcm9taXNlPFN3ZWV0QWxlcnRSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcblxuICAgICAgICBjb25zdCB1c2VyT3B0aW9ucyA9IHRoaXMuc3dhbE9wdGlvbnM7XG5cbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnVzZXJPcHRpb25zLFxuXG4gICAgICAgICAgICAvLz0+IEhhbmRsZSBtb2RhbCBsaWZlY3ljbGUgZXZlbnRzXG4gICAgICAgICAgICB3aWxsT3BlbjogY29tcG9zZUhvb2sodXNlck9wdGlvbnMud2lsbE9wZW4sIChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndpbGxPcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRpZE9wZW46IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLmRpZE9wZW4sIChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaWRSZW5kZXI6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLmRpZFJlbmRlciwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkUmVuZGVyLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdpbGxDbG9zZTogY29tcG9zZUhvb2sodXNlck9wdGlvbnMud2lsbENsb3NlLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy53aWxsQ2xvc2UuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGlkQ2xvc2U6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLmRpZENsb3NlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRDbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRpZERlc3Ryb3k6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLmRpZERlc3Ryb3ksICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZERlc3Ryb3kuZW1pdCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhIEFuZCB3YWl0IGZvciBjb25maXJtYXRpb24gb3IgZGltaXNzYWwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN3YWwuZmlyZShvcHRpb25zKTtcblxuICAgICAgICAvLz0+IEVtaXQgb24gKGNvbmZpcm0pLCAoZGVueSkgb3IgKGRpc21pc3MpXG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSByZXN1bHQuaXNDb25maXJtZWQ6IHRoaXMuY29uZmlybS5lbWl0KHJlc3VsdC52YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSByZXN1bHQuaXNEZW5pZWQ6IHRoaXMuZGVueS5lbWl0KCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSByZXN1bHQuaXNEaXNtaXNzZWQ6IHRoaXMuZGlzbWlzcy5lbWl0KHJlc3VsdC5kaXNtaXNzKTsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2VIb29rPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IHZvaWQ+KFxuICAgICAgICAgICAgdXNlckhvb2s6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICBsaWJIb29rOiBUKTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHZvaWQge1xuXG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChsaWJIb29rKC4uLmFyZ3MpLCB1c2VySG9vaz8uKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbW9kYWwsIGlmIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgVGhlIHZhbHVlIHRoYXQgdGhlIG1vZGFsIHdpbGwgcmVzb2x2ZSB3aXRoLCB0cmlnZ2VyaW5nIGVpdGhlciAoY29uZmlybSksIChkZW55KSBvciAoZGlzbWlzcykuXG4gICAgICogICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgaXQgaXMgKGRpc21pc3MpIHRoYXQgd2lsbCBlbWl0IGFuIGB1bmRlZmluZWRgIHJlYXNvbi5cbiAgICAgKiAgICAgICAgICAgICAgIHtAc2VlIFN3YWwuY2xvc2V9LlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBjbG9zZShyZXN1bHQ/OiBTd2VldEFsZXJ0UmVzdWx0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcbiAgICAgICAgc3dhbC5jbG9zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgU3dlZXRBbGVydDIgb3B0aW9ucyB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLCBjYXVzaW5nIHRoZSBtb2RhbCB0byByZS1yZW5kZXIuXG4gICAgICogSWYgdGhlIG1vZGFsIGlzIG5vdCBvcGVuZWQsIHRoZSBjb21wb25lbnQgb3B0aW9ucyB3aWxsIHNpbXBseSBiZSB1cGRhdGVkIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgbm90IGFsbCBTd2VldEFsZXJ0MiBvcHRpb25zIGFyZSB1cGRhdGFibGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZShvcHRpb25zPzogUGljazxTd2VldEFsZXJ0T3B0aW9ucywgU3dlZXRBbGVydFVwZGF0YWJsZVBhcmFtZXRlcnM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcblxuICAgICAgICBjb25zdCBhbGxPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICBjb25zdCB1cGRhdGFibGVPcHRpb25zID0gT2JqZWN0LmtleXMoYWxsT3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoc3dhbC5pc1VwZGF0YWJsZVBhcmFtZXRlcilcbiAgICAgICAgICAgIC5yZWR1Y2U8UGljazxTd2VldEFsZXJ0T3B0aW9ucywgU3dlZXRBbGVydFVwZGF0YWJsZVBhcmFtZXRlcnM+PihcbiAgICAgICAgICAgICAgICAob2JqLCBrZXkpID0+ICh7IC4uLm9iaiwgW2tleV06IGFsbE9wdGlvbnNba2V5XSB9KSxcbiAgICAgICAgICAgICAgICB7fSk7XG5cbiAgICAgICAgc3dhbC51cGRhdGUodXBkYXRhYmxlT3B0aW9ucyk7XG4gICAgfVxufVxuIl19