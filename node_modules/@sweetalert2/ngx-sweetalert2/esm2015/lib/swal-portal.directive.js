import { __awaiter } from "tslib";
import { ApplicationRef, ComponentFactoryResolver, Directive, Host, Injector, Input, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SwalPortalTargets } from './swal-portal-targets.service';
import { SwalPortalComponent } from './swal-portal.component';
import { SwalComponent } from './swal.component';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * A structural directive that lets you use Angular templates inside of SweetAlerts.
 * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but
 * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.
 * The default target is the alert text content zone.
 *
 * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):
 *
 *     @Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPortalTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPortal [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPortal="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
export class SwalPortalDirective {
    constructor(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
        this.destroyed = new Subject();
    }
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     */
    ngOnInit() {
        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
        this.target = this.target || this.swalTargets.content;
        //=> Apply the options provided by the target definition
        void this.swalComponent.update(this.target.options);
        //=> Subscribe to a few hooks frm the parent SwalComponent.
        this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));
        this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));
        this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));
    }
    /**
     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     */
    ngOnDestroy() {
        this.destroyed.next();
    }
    /**
     * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {@link willOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     */
    didRenderHook() {
        return __awaiter(this, void 0, void 0, function* () {
            //=> Ensure the portal component is created
            if (!this.portalComponentRef) {
                this.portalComponentRef = this.createPortalComponent();
            }
            //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
            // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
            // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
            // the portal component is fully synchronous, causing no blinks in the modal contents.
            const swal = yield this.sweetAlert2Loader.swal;
            //=> Find target element
            const targetEl = this.target.element(swal);
            if (!targetEl)
                return;
            //=> Replace target's contents with our component
            // https://jsperf.com/innerhtml-vs-removechild/15
            while (targetEl.firstChild) {
                targetEl.removeChild(targetEl.firstChild);
            }
            targetEl.appendChild(this.portalComponentRef.location.nativeElement);
        });
    }
    /**
     * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     */
    willOpenHook() {
        if (!this.portalComponentRef)
            return;
        //=> Make the Angular app aware of that detached view so rendering and change detection can happen
        this.app.attachView(this.portalComponentRef.hostView);
    }
    /**
     * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     */
    didDestroyHook() {
        if (!this.portalComponentRef)
            return;
        //=> Detach the portal component from the app and destroy it
        this.app.detachView(this.portalComponentRef.hostView);
        this.portalComponentRef.destroy();
        this.portalComponentRef = void 0;
    }
    /**
     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
     */
    createPortalComponent() {
        //=> Create the SwalPortalComponent that will hold our content
        const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
        // Yes, we do not use the third argument that would directly use the target as the component's view
        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
        // able to restore it at any moment, ie. after the modal has been re-rendered.
        const componentRef = factory.create(this.injector, []);
        //=> Apply the consumer's template on the component
        componentRef.instance.template = this.templateRef;
        return componentRef;
    }
}
SwalPortalDirective.decorators = [
    { type: Directive, args: [{
                selector: '[swalPortal]'
            },] }
];
SwalPortalDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ApplicationRef },
    { type: TemplateRef },
    { type: SweetAlert2LoaderService },
    { type: SwalPortalTargets },
    { type: SwalComponent, decorators: [{ type: Host }] }
];
SwalPortalDirective.propDecorators = {
    target: [{ type: Input, args: ['swalPortal',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC1wb3J0YWwuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXN3ZWV0YWxlcnQyL3NyYy9saWIvc3dhbC1wb3J0YWwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0gsY0FBYyxFQUFFLHdCQUF3QixFQUFnQixTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQ3hGLFdBQVcsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQW9CLGlCQUFpQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRXhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQUlILE1BQU0sT0FBTyxtQkFBbUI7SUFpQjVCLFlBQ3FCLFFBQWtDLEVBQ2xDLFFBQWtCLEVBQ2xCLEdBQW1CLEVBQ25CLFdBQTZCLEVBQzdCLGlCQUEyQyxFQUMzQyxXQUE4QixFQUN0QixhQUE0QjtRQU5wQyxhQUFRLEdBQVIsUUFBUSxDQUEwQjtRQUNsQyxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ2xCLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBQ25CLGdCQUFXLEdBQVgsV0FBVyxDQUFrQjtRQUM3QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQzNDLGdCQUFXLEdBQVgsV0FBVyxDQUFtQjtRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQVR4QyxjQUFTLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQVVqRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksUUFBUTtRQUNYLCtHQUErRztRQUMvRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7UUFFdEQsd0RBQXdEO1FBQ3hELEtBQUssSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVwRCwyREFBMkQ7UUFDM0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN0RyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3BHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDNUcsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFdBQVc7UUFDZCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ1csYUFBYTs7WUFDdkIsMkNBQTJDO1lBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzthQUMxRDtZQUVELHlHQUF5RztZQUN6Ryx3R0FBd0c7WUFDeEcseUdBQXlHO1lBQ3pHLHNGQUFzRjtZQUN0RixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7WUFFL0Msd0JBQXdCO1lBQ3hCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxRQUFRO2dCQUFFLE9BQU87WUFFdEIsaURBQWlEO1lBQ2pELGlEQUFpRDtZQUNqRCxPQUFPLFFBQVEsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3hCLFFBQVEsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzdDO1lBRUQsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pFLENBQUM7S0FBQTtJQUVEOzs7T0FHRztJQUNLLFlBQVk7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0I7WUFBRSxPQUFPO1FBRXJDLGtHQUFrRztRQUNsRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGNBQWM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0I7WUFBRSxPQUFPO1FBRXJDLDREQUE0RDtRQUM1RCxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUI7UUFDekIsOERBQThEO1FBQzlELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUUzRSxtR0FBbUc7UUFDbkcsNEdBQTRHO1FBQzVHLHdHQUF3RztRQUN4Ryw4RUFBOEU7UUFDOUUsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXZELG1EQUFtRDtRQUNuRCxZQUFZLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBRWxELE9BQU8sWUFBWSxDQUFDO0lBQ3hCLENBQUM7OztZQTlISixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGNBQWM7YUFDM0I7OztZQTFDbUIsd0JBQXdCO1lBQWlDLFFBQVE7WUFBakYsY0FBYztZQUNkLFdBQVc7WUFPTix3QkFBd0I7WUFITixpQkFBaUI7WUFFbkMsYUFBYSx1QkE0RGIsSUFBSTs7O3FCQWpCUixLQUFLLFNBQUMsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEhvc3QsIEluamVjdG9yLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTd2FsUG9ydGFsVGFyZ2V0LCBTd2FsUG9ydGFsVGFyZ2V0cyB9IGZyb20gJy4vc3dhbC1wb3J0YWwtdGFyZ2V0cy5zZXJ2aWNlJztcbmltcG9ydCB7IFN3YWxQb3J0YWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwtcG9ydGFsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlJztcblxuLyoqXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRoYXQgbGV0cyB5b3UgdXNlIEFuZ3VsYXIgdGVtcGxhdGVzIGluc2lkZSBvZiBTd2VldEFsZXJ0cy5cbiAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgdGFyZ2V0YWJsZSB6b25lcyBwcm92aWRlZCBieSB7QGxpbmsgU3dhbFBvcnRhbFRhcmdldHN9OiB0aXRsZSwgY29udGVudCwgY29uZmlybUJ1dHRvbiwgZXRjLCBidXRcbiAqIHlvdSBjYW4gYWxzbyBtYWtlIHlvdXIgb3duIHRhcmdldCBieSBpbXBsZW1lbnRpbmcge0BsaW5rIFN3YWxQb3J0YWxUYXJnZXR9IGFuZCBnaXZpbmcgaXQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKiBUaGUgZGVmYXVsdCB0YXJnZXQgaXMgdGhlIGFsZXJ0IHRleHQgY29udGVudCB6b25lLlxuICpcbiAqIFVzYWdlIGluIHlvdXIgY29tcG9uZW50J3MgVHlwZVNjcmlwdCAoaWYgeW91IHVzZSBhbm90aGVyIHRhcmdldCB0aGFuIHtAbGluayBTd2FsUG9ydGFsVGFyZ2V0cy5jb250ZW50fSk6XG4gKlxuICogICAgIEBDb21wb25lbnQoeyAuLi4gfSlcbiAqICAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICAgICAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHN3YWxUYXJnZXRzOiBTd2FsUG9ydGFsVGFyZ2V0cykge1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFVzYWdlIGluIHRoZSB0ZW1wbGF0ZTpcbiAqXG4gKiAgICAgPHN3YWwgdGl0bGU9XCJGaWxsIHRoZSBmb3JtXCIgKGNvbmZpcm0pPVwiY29uZmlybUhhbmRsZXIoKVwiPlxuICogICAgICAgICA8IS0tIFRoaXMgZm9ybSB3aWxsIGJlIGRpc3BsYXllZCBhcyB0aGUgYWxlcnQgbWFpbiBjb250ZW50XG4gKiAgICAgICAgICAgICAgVGFyZ2V0cyB0aGUgYWxlcnQncyBtYWluIGNvbnRlbnQgem9uZSBieSBkZWZhdWx0IC0tPlxuICogICAgICAgICA8Zm9ybSAqc3dhbFBvcnRhbCBbZm9ybUNvbnRyb2xdPVwibXlGb3JtXCI+XG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICAgICAgPCEtLSBUaGlzIHRhcmdldHMgdGhlIGNvbmZpcm0gYnV0dG9uJ3MgaW5uZXIgY29udGVudFxuICogICAgICAgICAgICAgIE5vdGljZSB0aGUgdXNhZ2Ugb2YgbmctY29udGFpbmVyIHRvIGF2b2lkIGNyZWF0aW5nIGFuIHVzZWxlc3MgRE9NIGVsZW1lbnQgaW5zaWRlIHRoZSBidXR0b24gLS0+XG4gKiAgICAgICAgIDxuZy1jb250YWluZXIgKnN3YWxQb3J0YWw9XCJzd2FsVGFyZ2V0cy5jb25maXJtQnV0dG9uXCI+XG4gKiAgICAgICAgICAgICAgU2VuZCAoe3sgc2Vjb25kc0xlZnQgfX0gc2Vjb25kcyBsZWZ0KVxuICogICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAqICAgICA8c3dhbD5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbc3dhbFBvcnRhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxQb3J0YWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBwb3J0YWwgdGFyZ2V0IG9yIG5vdGhpbmcgKHRoZW4gaXQgd2lsbCB0YXJnZXQgdGhlIHRleHQgY29udGVudCB6b25lIGJ5IGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogU2VlIHRoZSB7QGxpbmsgU3dhbFBvcnRhbFRhcmdldHN9IHNlcnZpY2UgdG8gc2VlIHRoZSBhdmFpbGFibGUgdGFyZ2V0cy5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCdzd2FsUG9ydGFsJylcbiAgICBwdWJsaWMgdGFyZ2V0PzogU3dhbFBvcnRhbFRhcmdldDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlIG9mIHRoZSBjb250cm9sbGVkIFN3YWxQb3J0YWxDb21wb25lbnQgdG8gZGVzdHJveSBpdCB3aGVuIG5vIGxvbmdlciBuZWVkZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwb3J0YWxDb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8U3dhbFBvcnRhbENvbXBvbmVudD47XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwOiBBcHBsaWNhdGlvblJlZixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzd2VldEFsZXJ0MkxvYWRlcjogU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHN3YWxUYXJnZXRzOiBTd2FsUG9ydGFsVGFyZ2V0cyxcbiAgICAgICAgQEhvc3QoKSBwcml2YXRlIHJlYWRvbmx5IHN3YWxDb21wb25lbnQ6IFN3YWxDb21wb25lbnQpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSB0aGUgU3dlZXRBbGVydCBhcHBlYXJhbmNlL2Rpc2FwcGVhcmFuY2UgZXZlbnRzIHRvIGNyZWF0ZS9kZXN0cm95IHRoZSBTd2FsUG9ydGFsQ29tcG9uZW50XG4gICAgICogdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGNvbnN1bWVyJ3MgdGVtcGxhdGUuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBDYW4ndCBiZSBzZXQgaW4gYSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlLCBpZiB0aGUgY3VzdG9tZXIgbGV0cyAqc3dhbFBvcnRhbCBlbXB0eSwgdGhlIHZhbHVlIHdlIGdldCBpcyB1bmRlZi5cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLnRhcmdldCB8fCB0aGlzLnN3YWxUYXJnZXRzLmNvbnRlbnQ7XG5cbiAgICAgICAgLy89PiBBcHBseSB0aGUgb3B0aW9ucyBwcm92aWRlZCBieSB0aGUgdGFyZ2V0IGRlZmluaXRpb25cbiAgICAgICAgdm9pZCB0aGlzLnN3YWxDb21wb25lbnQudXBkYXRlKHRoaXMudGFyZ2V0Lm9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gU3Vic2NyaWJlIHRvIGEgZmV3IGhvb2tzIGZybSB0aGUgcGFyZW50IFN3YWxDb21wb25lbnQuXG4gICAgICAgIHRoaXMuc3dhbENvbXBvbmVudC5kaWRSZW5kZXIucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpKS5zdWJzY3JpYmUodGhpcy5kaWRSZW5kZXJIb29rLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN3YWxDb21wb25lbnQud2lsbE9wZW4ucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpKS5zdWJzY3JpYmUodGhpcy53aWxsT3Blbkhvb2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3dhbENvbXBvbmVudC5kaWREZXN0cm95LnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveWVkKSkuc3Vic2NyaWJlKHRoaXMuZGlkRGVzdHJveUhvb2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2lnbmFsIGFueSB7QGxpbmsgZGVzdHJveWVkfSBjb25zdW1lciB0aGF0IHRoaXMgaXMgb3Zlciwgc28gdGhleSBjYW4gdW5zdWJzY3JpYmUgZnJvbSB0aGVcbiAgICAgKiBwYXJlbnQgU3dhbENvbXBvbmVudCBldmVudHMuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZC5uZXh0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBkaWRSZW5kZXIgaG9vayBydW5zIDEuLm4gdGltZXMgKHBlciBtb2RhbCBpbnN0YW5jZSksIGp1c3QgYmVmb3JlIHRoZSBtb2RhbCBpcyBzaG93biAoYW5kIGFsc28gYmVmb3JlIHRoZVxuICAgICAqIHtAbGluayB3aWxsT3Blbkhvb2t9KSwgb3IgYWZ0ZXIgU3dhbC51cGRhdGUoKSBpcyBjYWxsZWQuXG4gICAgICogVGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gcmVuZGVyLCBvciByZS1yZW5kZXIsIG91ciBwb3J0YWwgY29udGVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBkaWRSZW5kZXJIb29rKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLz0+IEVuc3VyZSB0aGUgcG9ydGFsIGNvbXBvbmVudCBpcyBjcmVhdGVkXG4gICAgICAgIGlmICghdGhpcy5wb3J0YWxDb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsQ29tcG9uZW50UmVmID0gdGhpcy5jcmVhdGVQb3J0YWxDb21wb25lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vPT4gU3dlZXRBbGVydDIgY3JlYXRlZCB0aGUgbW9kYWwgb3IganVzdCBlcmFzZWQgYWxsIG9mIG91ciBjb250ZW50LCBzbyB3ZSBuZWVkIHRvIGluc3RhbGwvcmVpbnN0YWxsIGl0LlxuICAgICAgICAvLyBTd2FsLnVwZGF0ZSgpIGlzIHN5bmNocm9ub3VzLCB0aGlzIG9ic2VydmFibGUgdG9vLCBhbmQgbW91bnRDb21wb25lbnRPblRhcmdldCB0b28gKHRoZSBwcm9taXNlIGluc2lkZVxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGFscmVhZHkgcmVzb2x2ZWQgYXQgdGhpcyBwb2ludCksIHNvIHRoZSB3aG9sZSBwcm9jZXNzIG9mIHJlLXJlbmRlcmluZyBhbmQgcmUtbW91bnRpbmdcbiAgICAgICAgLy8gdGhlIHBvcnRhbCBjb21wb25lbnQgaXMgZnVsbHkgc3luY2hyb25vdXMsIGNhdXNpbmcgbm8gYmxpbmtzIGluIHRoZSBtb2RhbCBjb250ZW50cy5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcblxuICAgICAgICAvLz0+IEZpbmQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLnRhcmdldCEuZWxlbWVudChzd2FsKTtcbiAgICAgICAgaWYgKCF0YXJnZXRFbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vPT4gUmVwbGFjZSB0YXJnZXQncyBjb250ZW50cyB3aXRoIG91ciBjb21wb25lbnRcbiAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2lubmVyaHRtbC12cy1yZW1vdmVjaGlsZC8xNVxuICAgICAgICB3aGlsZSAodGFyZ2V0RWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2hpbGQodGFyZ2V0RWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRFbC5hcHBlbmRDaGlsZCh0aGlzLnBvcnRhbENvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGxPcGVuIGhvb2sgcnVucyBvbmNlIChwZXIgbW9kYWwgaW5zdGFuY2UpLCBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24gb24gdGhlIHNjcmVlbi5cbiAgICAgKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSB0byBkZWNsYXJlIG91ciBkZXRhY2hlZCB2aWV3IHRvIHRoZSBBbmd1bGFyIGFwcC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHdpbGxPcGVuSG9vaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcnRhbENvbXBvbmVudFJlZikgcmV0dXJuO1xuXG4gICAgICAgIC8vPT4gTWFrZSB0aGUgQW5ndWxhciBhcHAgYXdhcmUgb2YgdGhhdCBkZXRhY2hlZCB2aWV3IHNvIHJlbmRlcmluZyBhbmQgY2hhbmdlIGRldGVjdGlvbiBjYW4gaGFwcGVuXG4gICAgICAgIHRoaXMuYXBwLmF0dGFjaFZpZXcodGhpcy5wb3J0YWxDb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZGlkRGVzdHJveSBob29rIHJ1bnMgb25jZSAocGVyIG1vZGFsIGluc3RhbmNlKSwganVzdCBhZnRlciB0aGUgbW9kYWwgY2xvc2luZyBhbmltYXRpb24gdGVybWluYXRlZC5cbiAgICAgKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSB0byBkZXRhY2ggYW5kIGRlc3Ryb3kgb3VyIGNvbnRlbnQsIHRoYXQgaXMgbm90IHZpc2libGUgYW55bW9yZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRpZERlc3Ryb3lIb29rKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMucG9ydGFsQ29tcG9uZW50UmVmKSByZXR1cm47XG5cbiAgICAgICAgLy89PiBEZXRhY2ggdGhlIHBvcnRhbCBjb21wb25lbnQgZnJvbSB0aGUgYXBwIGFuZCBkZXN0cm95IGl0XG4gICAgICAgIHRoaXMuYXBwLmRldGFjaFZpZXcodGhpcy5wb3J0YWxDb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICB0aGlzLnBvcnRhbENvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucG9ydGFsQ29tcG9uZW50UmVmID0gdm9pZCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHtAbGluayBTd2FsUG9ydGFsQ29tcG9uZW50fSBhbmQgZ2l2ZXMgaXQgdGhlIGN1c3RvbWVyJ3MgdGVtcGxhdGUgcmVmLlxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlUG9ydGFsQ29tcG9uZW50KCk6IENvbXBvbmVudFJlZjxTd2FsUG9ydGFsQ29tcG9uZW50PiB7XG4gICAgICAgIC8vPT4gQ3JlYXRlIHRoZSBTd2FsUG9ydGFsQ29tcG9uZW50IHRoYXQgd2lsbCBob2xkIG91ciBjb250ZW50XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN3YWxQb3J0YWxDb21wb25lbnQpO1xuXG4gICAgICAgIC8vIFllcywgd2UgZG8gbm90IHVzZSB0aGUgdGhpcmQgYXJndW1lbnQgdGhhdCB3b3VsZCBkaXJlY3RseSB1c2UgdGhlIHRhcmdldCBhcyB0aGUgY29tcG9uZW50J3Mgdmlld1xuICAgICAgICAvLyAodW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjbGVhbmVyIERPTSBhbmQgd291bGQgYXZvaWQgZGlydHkgYW5kIGRpcmVjdCBET00gbWFuaXB1bGF0aW9ucylcbiAgICAgICAgLy8gVGhhdCdzIGJlY2F1c2Ugd2Ugd2FudCB0byBrZWVwIG91ciBjb21wb25lbnQgc2FmZSBmcm9tIFN3ZWV0QWxlcnQyJ3Mgb3BlcmF0aW9ucyBvbiB0aGUgRE9NLCBhbmQgdG8gYmVcbiAgICAgICAgLy8gYWJsZSB0byByZXN0b3JlIGl0IGF0IGFueSBtb21lbnQsIGllLiBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmUtcmVuZGVyZWQuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IsIFtdKTtcblxuICAgICAgICAvLz0+IEFwcGx5IHRoZSBjb25zdW1lcidzIHRlbXBsYXRlIG9uIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVJlZjtcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH1cbn1cbiJdfQ==